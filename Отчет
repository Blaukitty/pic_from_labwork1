Данные
Взяли RGB-изображение размером 200×200 пикселей (каждый канал — uint8).

Алгоритм
Классический фильтр Гаусса с ядром 3×3:
 [1/16, 2/16, 1/16],
 [2/16, 4/16, 2/16],
 [1/16, 2/16, 1/16]
копируются граничные строки/столбцы, остальные пиксели out[y,x] считаются как взвешенная сумма соседних 9 пикселей.

Независимые реализации
Последовательная версия: двойной вложенный цикл по y=1..h−2 и x=1..w−2, внутренняя работа с соседними 3×3.

Параллельная версия:
Делит изображение на две “горизонтальные” части (строки 0..99 и 100..199).
Запускает два процесса, каждый обрабатывает свою половину (включая границу: y=0 или y=h−1, попадает в соответствующий
процесс и просто копируется).
Результаты двух процессов собираются в общий буфер.

Измерения
Каждый вариант запущен 3 раза. Для каждой итерации записывалось время выполнения (в ms). Затем вычислено среднее по
трём прогону для последовательной и для параллельной версии.

2. Таблица результатов
Run	 Послед (ms)	Пар (ms)	
1	   1195.04	    788.22	  
2	   1193.50	    800.55	  
3	   1196.40	    799.53	  

Среднее Seq: 1194.98 ms
Среднее Par: 796.10 ms

Для вычислений использовался python.

3. Интерпретация результатов
Последовательная версия занимает примерно 1.19 секунды (≈1195 ms) на полном изображении 200×200.
