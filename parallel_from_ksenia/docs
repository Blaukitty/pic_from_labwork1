За основы был взят проеткт Князевой Евы, изменена была только половина проекта, что описано ниже.
  
Я добавила заголовки: 
#include <thread>
#include <vector>
#include <algorithm>

Определены несколько static-функций, выполняющих часть работы для каждого потока:
rotateClockwiseWorker(...)
rotateCounterClockwiseWorker(...)
gaussianBlurWorker(...)

Методы rotateClockwise(), rotateCounterClockwise() и gaussianBlur() создают несколько потоков, передают каждому свой диапазон
строк и дожидаются join(). После чего старый буфер удаляется, а указатель pixels перенаправляется на новый.
  
static void rotateClockwiseWorker(
    Pixel** pixels,
    Pixel** rotated,
    int oldW,
    int oldH,
    int i_start,
    int i_end
) {
    for (int i = i_start; i < i_end; ++i) {
        for (int j = 0; j < oldW; ++j) {
            rotated[j][oldH - i - 1] = pixels[i][j];
        }
    }
}
Аргументы:
Pixel** pixels — исходный массив [oldH][oldW].
Pixel** rotated — буфер [oldW][oldH], куда записываем результат.
oldW, oldH — прежние ширина и высота (высота по модулю).
i_start, i_end — диапазон строк исходного изображения, которые должен обработать этот поток.

static void rotateCounterClockwiseWorker(...) работает аналогично.

static void gaussianBlurWorker(...)
static void gaussianBlurWorker(
    Pixel** pixels,
    Pixel** temporary,
    int width,
    int height,
    int y_start,
    int y_end
) {
    const int kSize = 3;
    const float kernel[kSize][kSize] = {
        {1/16.f, 2/16.f, 1/16.f},
        {2/16.f, 4/16.f, 2/16.f},
        {1/16.f, 2/16.f, 1/16.f}
    };

    for (int y = y_start; y < y_end; ++y) {
        if (y < 1 || y >= height - 1) continue;
        for (int x = 1; x < width - 1; ++x) {
            float red = 0.f, green = 0.f, blue = 0.f;
            for (int ky = -1; ky <= 1; ++ky) {
                for (int kx = -1; kx <= 1; ++kx) {
                    Pixel &p = pixels[y + ky][x + kx];
                    red   += p.red   * kernel[ky + 1][kx + 1];
                    green += p.green * kernel[ky + 1][kx + 1];
                    blue  += p.blue  * kernel[ky + 1][kx + 1];
                }
            }
            temporary[y][x].red   = static_cast<uint8_t>(red);
            temporary[y][x].green = static_cast<uint8_t>(green);
            temporary[y][x].blue  = static_cast<uint8_t>(blue);
        }
    }
}
Аргументы:
Pixel** pixels — исходный массив [height][width].
Pixel** temporary — буфер [height][width], куда пишутся размазанные пиксели.
width, height — размеры изображения.
y_start, y_end — диапазон строк, которые обрабатывает этот поток.
Логика:
Для каждого (y, x) внутри (без граничных пикселей) вычисляется взвешенная сумма соседей по 3×3 ядру.
Граничные пиксели (первые и последние строки, первые и последние столбцы) не обрабатываются здесь — они копируются
без изменений после завершения всех потоков.

Поворот по часовой стрелке:
1. Выделение нового буфера rotated[oldW][oldH]
2. Определение числа потоков
3. Разбиение строк [0..oldH) на numThr частей
4. Ожидание завершения потоков
5. Освобождение старого буфера
6. Сохранение нового буфера
7. Обмен width и height

Поворот против часовой стрелки аналогично.

Гаусово размытие 3х3:
1. Выделение временного буфера temporary[height][width]
2. Определяем число потоков
3. Разбиение строк [0..height) на numThr частей
4. Ожидание завершения потоков
5. Копирование граничных пикселей без размытия
6. Копирование результата в pixels и освобождение temporary
